/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * FinchAPI
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface Allocation
 */
export interface Allocation {
    /**
     *
     * @type {string}
     * @memberof Allocation
     */
    description: string;
    /**
     *
     * @type {number}
     * @memberof Allocation
     */
    date: number;
    /**
     *
     * @type {{ [key: string]: AssetToPercentMapping; }}
     * @memberof Allocation
     */
    mapping: { [key: string]: AssetToPercentMapping; };
}
/**
 *
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     *
     * @type {number}
     * @memberof ApiError
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof ApiError
     */
    message: string;
}
/**
 *
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof Asset
     */
    _class: string;
    /**
     * Annualised Percentage Performance
     * @type {number}
     * @memberof Asset
     */
    performance: number;
}
/**
 *
 * @export
 * @interface AssetToPercentMapping
 */
export interface AssetToPercentMapping {
    /**
     *
     * @type {number}
     * @memberof AssetToPercentMapping
     */
    percentage: number;
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
    /**
     *
     * @type {string}
     * @memberof Event
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof Event
     */
    start: number;
    /**
     *
     * @type {Array<Transform>}
     * @memberof Event
     */
    transforms: Array<Transform>;
}
/**
 *
 * @export
 * @interface Goal
 */
export interface Goal {
    /**
     *
     * @type {MongoObjectID}
     * @memberof Goal
     */
    id: MongoObjectID;
    /**
     *
     * @type {string}
     * @memberof Goal
     */
    name: string;
    /**
     *
     * @type {TimePeriod}
     * @memberof Goal
     */
    period: TimePeriod;
    /**
     *
     * @type {number}
     * @memberof Goal
     */
    threshold: number;
    /**
     *
     * @type {string}
     * @memberof Goal
     */
    goalSide: Goal.GoalSideEnum;
    /**
     *
     * @type {boolean}
     * @memberof Goal
     */
    completed: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Goal
     */
    feasible?: boolean;
}

/**
 * @export
 * @namespace Goal
 */
export namespace Goal {
    /**
     * @export
     * @enum {string}
     */
    export enum GoalSideEnum {
        Above = <any> 'above',
        Below = <any> 'below'
    }
}
/**
 *
 * @export
 * @interface GoalNewPayload
 */
export interface GoalNewPayload {
    /**
     *
     * @type {string}
     * @memberof GoalNewPayload
     */
    name: string;
    /**
     *
     * @type {TimePeriod}
     * @memberof GoalNewPayload
     */
    period: TimePeriod;
    /**
     *
     * @type {number}
     * @memberof GoalNewPayload
     */
    threshold: number;
    /**
     *
     * @type {string}
     * @memberof GoalNewPayload
     */
    goalSide: GoalNewPayload.GoalSideEnum;
}

/**
 * @export
 * @namespace GoalNewPayload
 */
export namespace GoalNewPayload {
    /**
     * @export
     * @enum {string}
     */
    export enum GoalSideEnum {
        Above = <any> 'above',
        Below = <any> 'below'
    }
}
/**
 *
 * @export
 * @interface Insight
 */
export interface Insight {
    /**
     *
     * @type {string}
     * @memberof Insight
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof Insight
     */
    description: string;
    /**
     *
     * @type {string}
     * @memberof Insight
     */
    logo?: string;
    /**
     *
     * @type {string}
     * @memberof Insight
     */
    typ: string;
    /**
     *
     * @type {boolean}
     * @memberof Insight
     */
    dismissed: boolean;
}
/**
 *
 * @export
 * @interface ItemIdResponse
 */
export interface ItemIdResponse {
    /**
     * Item ID for newly added account
     * @type {string}
     * @memberof ItemIdResponse
     */
    itemId: string;
}
/**
 *
 * @export
 * @interface KnownFinancialProduct
 */
export interface KnownFinancialProduct {
    /**
     *
     * @type {string}
     * @memberof KnownFinancialProduct
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof KnownFinancialProduct
     */
    typ: string;
    /**
     *
     * @type {string}
     * @memberof KnownFinancialProduct
     */
    logo: string;
    /**
     *
     * @type {string}
     * @memberof KnownFinancialProduct
     */
    productUrl: string;
}
/**
 *
 * @export
 * @interface LeaderboardResponse
 */
export interface LeaderboardResponse {
    /**
     *
     * @type {string}
     * @memberof LeaderboardResponse
     */
    leaderboardType: string;
    /**
     *
     * @type {string}
     * @memberof LeaderboardResponse
     */
    description?: string;
    /**
     *
     * @type {number}
     * @memberof LeaderboardResponse
     */
    percentile: number;
}
/**
 *
 * @export
 * @interface LinkTokenCreateResponse
 */
export interface LinkTokenCreateResponse {
    /**
     *
     * @type {string}
     * @memberof LinkTokenCreateResponse
     */
    linkToken: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenCreateResponse
     */
    expiration: string;
    /**
     *
     * @type {string}
     * @memberof LinkTokenCreateResponse
     */
    requestId?: string;
}
/**
 *
 * @export
 * @interface LoginPayload
 */
export interface LoginPayload {
    /**
     *
     * @type {string}
     * @memberof LoginPayload
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof LoginPayload
     */
    password: string;
}
/**
 *
 * @export
 * @interface MongoObjectID
 */
export interface MongoObjectID {
    /**
     *
     * @type {string}
     * @memberof MongoObjectID
     */
    oid: string;
}
/**
 *
 * @export
 * @interface PlaidJWT
 */
export interface PlaidJWT {
    /**
     *
     * @type {string}
     * @memberof PlaidJWT
     */
    alg: string;
    /**
     *
     * @type {string}
     * @memberof PlaidJWT
     */
    kid: string;
    /**
     *
     * @type {string}
     * @memberof PlaidJWT
     */
    typ: string;
}
/**
 *
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     *
     * @type {MongoObjectID}
     * @memberof Plan
     */
    id: MongoObjectID;
    /**
     *
     * @type {string}
     * @memberof Plan
     */
    name: string;
    /**
     *
     * @type {Array<Recurring>}
     * @memberof Plan
     */
    recurrings?: Array<Recurring>;
    /**
     *
     * @type {Array<Allocation>}
     * @memberof Plan
     */
    allocations?: Array<Allocation>;
    /**
     *
     * @type {Array<Event>}
     * @memberof Plan
     */
    events?: Array<Event>;
}
/**
 *
 * @export
 * @interface PlanNewPayload
 */
export interface PlanNewPayload {
    /**
     *
     * @type {string}
     * @memberof PlanNewPayload
     */
    name: string;
    /**
     *
     * @type {Array<Recurring>}
     * @memberof PlanNewPayload
     */
    recurrings?: Array<Recurring>;
    /**
     *
     * @type {Array<Transform>}
     * @memberof PlanNewPayload
     */
    allocations?: Array<Transform>;
    /**
     *
     * @type {Array<Event>}
     * @memberof PlanNewPayload
     */
    events?: Array<Event>;
}
/**
 *
 * @export
 * @interface PublicTokenExchangeRequest
 */
export interface PublicTokenExchangeRequest {
    /**
     *
     * @type {string}
     * @memberof PublicTokenExchangeRequest
     */
    publicToken: string;
    /**
     *
     * @type {string}
     * @memberof PublicTokenExchangeRequest
     */
    clientId?: string;
    /**
     *
     * @type {string}
     * @memberof PublicTokenExchangeRequest
     */
    secret?: string;
}
/**
 *
 * @export
 * @interface Recurring
 */
export interface Recurring {
    /**
     *
     * @type {MongoObjectID}
     * @memberof Recurring
     */
    id: MongoObjectID;
    /**
     *
     * @type {string}
     * @memberof Recurring
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof Recurring
     */
    start: number;
    /**
     *
     * @type {number}
     * @memberof Recurring
     */
    end: number;
    /**
     *
     * @type {number}
     * @memberof Recurring
     */
    principal: number;
    /**
     *
     * @type {number}
     * @memberof Recurring
     */
    amount: number;
    /**
     *
     * @type {number}
     * @memberof Recurring
     */
    interest: number;
    /**
     *
     * @type {TimeInterval}
     * @memberof Recurring
     */
    frequency: TimeInterval;
}
/**
 *
 * @export
 * @interface RecurringNewPayload
 */
export interface RecurringNewPayload {
    /**
     *
     * @type {string}
     * @memberof RecurringNewPayload
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof RecurringNewPayload
     */
    start: number;
    /**
     *
     * @type {number}
     * @memberof RecurringNewPayload
     */
    end: number;
    /**
     *
     * @type {number}
     * @memberof RecurringNewPayload
     */
    principal: number;
    /**
     *
     * @type {number}
     * @memberof RecurringNewPayload
     */
    amount: number;
    /**
     *
     * @type {number}
     * @memberof RecurringNewPayload
     */
    interest: number;
    /**
     *
     * @type {TimeInterval}
     * @memberof RecurringNewPayload
     */
    frequency: TimeInterval;
}
/**
 *
 * @export
 * @interface SignupPayload
 */
export interface SignupPayload {
    /**
     *
     * @type {string}
     * @memberof SignupPayload
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof SignupPayload
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof SignupPayload
     */
    firstName: string;
    /**
     *
     * @type {string}
     * @memberof SignupPayload
     */
    lastName: string;
    /**
     *
     * @type {number}
     * @memberof SignupPayload
     */
    income: number;
}
/**
 *
 * @export
 * @interface TimeInterval
 */
export interface TimeInterval {
    /**
     *
     * @type {string}
     * @memberof TimeInterval
     */
    typ: TimeInterval.TypEnum;
    /**
     *
     * @type {number}
     * @memberof TimeInterval
     */
    content: number;
}

/**
 * @export
 * @namespace TimeInterval
 */
export namespace TimeInterval {
    /**
     * @export
     * @enum {string}
     */
    export enum TypEnum {
        Monthly = <any> 'monthly',
        Annually = <any> 'annually',
        Daily = <any> 'daily',
        Weekly = <any> 'weekly'
    }
}
/**
 *
 * @export
 * @interface TimePeriod
 */
export interface TimePeriod {
    /**
     *
     * @type {number}
     * @memberof TimePeriod
     */
    start: number;
    /**
     *
     * @type {number}
     * @memberof TimePeriod
     */
    end: number;
}
/**
 * Daily values starting on some day.
 * @export
 * @interface TimeSeries
 */
export interface TimeSeries {
    /**
     *
     * @type {number}
     * @memberof TimeSeries
     */
    startDay: number;
    /**
     *
     * @type {Array<number>}
     * @memberof TimeSeries
     */
    series: Array<number>;
}
/**
 *
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     *
     * @type {number}
     * @memberof Transform
     */
    trigger: number;
    /**
     *
     * @type {{ [key: string]: AssetToPercentMapping; }}
     * @memberof Transform
     */
    change: { [key: string]: AssetToPercentMapping; };
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    lastName?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateUserRequest
     */
    income?: number;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     *
     * @type {UserLocation}
     * @memberof User
     */
    location: UserLocation;
    /**
     *
     * @type {string}
     * @memberof User
     */
    firstName: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    lastName: string;
    /**
     *
     * @type {number}
     * @memberof User
     */
    income?: number;
    /**
     *
     * @type {string}
     * @memberof User
     */
    deviceUrl?: string;
}
/**
 *
 * @export
 * @interface UserLocation
 */
export interface UserLocation {
    /**
     *
     * @type {number}
     * @memberof UserLocation
     */
    lat: number;
    /**
     *
     * @type {number}
     * @memberof UserLocation
     */
    lon: number;
}
/**
 *
 * @export
 * @interface ValidateUserPayload
 */
export interface ValidateUserPayload {
    /**
     *
     * @type {string}
     * @memberof ValidateUserPayload
     */
    typ: ValidateUserPayload.TypEnum;
    /**
     *
     * @type {string}
     * @memberof ValidateUserPayload
     */
    content: string;
}

/**
 * @export
 * @namespace ValidateUserPayload
 */
export namespace ValidateUserPayload {
    /**
     * @export
     * @enum {string}
     */
    export enum TypEnum {
        Email = <any> 'email',
        Password = <any> 'password'
    }
}
/**
 * GoalApi - fetch parameter creator
 * @export
 */
export const GoalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete one specific goal by id
         * @param {string} id Numeric ID of the Goal to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteGoal.');
            }
            const localVarPath = `/goal/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get one specific goal by id
         * @param {string} id Numeric ID of the Goal to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGoal.');
            }
            const localVarPath = `/goal/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all of a user's goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(options: any = {}): FetchArgs {
            const localVarPath = `/goals`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new goal for the user
         * @param {GoalNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newGoal(body: GoalNewPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling newGoal.');
            }
            const localVarPath = `/goal/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GoalNewPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update one specific goal by id
         * @param {string} id Numeric ID of the Goal to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateGoal.');
            }
            const localVarPath = `/goal/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoalApi - functional programming interface
 * @export
 */
export const GoalApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete one specific goal by id
         * @param {string} id Numeric ID of the Goal to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Goal> {
            const localVarFetchArgs = GoalApiFetchParamCreator(configuration).deleteGoal(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get one specific goal by id
         * @param {string} id Numeric ID of the Goal to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Goal> {
            const localVarFetchArgs = GoalApiFetchParamCreator(configuration).getGoal(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all of a user's goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Goal>> {
            const localVarFetchArgs = GoalApiFetchParamCreator(configuration).getGoals(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a new goal for the user
         * @param {GoalNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newGoal(body: GoalNewPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Goal> {
            const localVarFetchArgs = GoalApiFetchParamCreator(configuration).newGoal(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update one specific goal by id
         * @param {string} id Numeric ID of the Goal to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Goal> {
            const localVarFetchArgs = GoalApiFetchParamCreator(configuration).updateGoal(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GoalApi - factory interface
 * @export
 */
export const GoalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Delete one specific goal by id
         * @param {string} id Numeric ID of the Goal to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGoal(id: string, options?: any) {
            return GoalApiFp(configuration).deleteGoal(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get one specific goal by id
         * @param {string} id Numeric ID of the Goal to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoal(id: string, options?: any) {
            return GoalApiFp(configuration).getGoal(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all of a user's goals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGoals(options?: any) {
            return GoalApiFp(configuration).getGoals(options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new goal for the user
         * @param {GoalNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newGoal(body: GoalNewPayload, options?: any) {
            return GoalApiFp(configuration).newGoal(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update one specific goal by id
         * @param {string} id Numeric ID of the Goal to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGoal(id: string, options?: any) {
            return GoalApiFp(configuration).updateGoal(id, options)(fetch, basePath);
        },
    };
};

/**
 * GoalApi - object-oriented interface
 * @export
 * @class GoalApi
 * @extends {BaseAPI}
 */
export class GoalApi extends BaseAPI {
    /**
     *
     * @summary Delete one specific goal by id
     * @param {string} id Numeric ID of the Goal to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalApi
     */
    public deleteGoal(id: string, options?: any) {
        return GoalApiFp(this.configuration).deleteGoal(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get one specific goal by id
     * @param {string} id Numeric ID of the Goal to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalApi
     */
    public getGoal(id: string, options?: any) {
        return GoalApiFp(this.configuration).getGoal(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all of a user's goals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalApi
     */
    public getGoals(options?: any) {
        return GoalApiFp(this.configuration).getGoals(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Creates a new goal for the user
     * @param {GoalNewPayload} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalApi
     */
    public newGoal(body: GoalNewPayload, options?: any) {
        return GoalApiFp(this.configuration).newGoal(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update one specific goal by id
     * @param {string} id Numeric ID of the Goal to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoalApi
     */
    public updateGoal(id: string, options?: any) {
        return GoalApiFp(this.configuration).updateGoal(id, options)(this.fetch, this.basePath);
    }

}
/**
 * InsightsApi - fetch parameter creator
 * @export
 */
export const InsightsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Dismiss an insight
         * @param {string} id Numeric ID of the Insight to dismiss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dismissInsight(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling dismissInsight.');
            }
            const localVarPath = `/insight/{id}/dismiss`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all a user's (non-dismissed) insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsights(options: any = {}): FetchArgs {
            const localVarPath = `/insights`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightsApi - functional programming interface
 * @export
 */
export const InsightsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Dismiss an insight
         * @param {string} id Numeric ID of the Insight to dismiss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dismissInsight(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Insight> {
            const localVarFetchArgs = InsightsApiFetchParamCreator(configuration).dismissInsight(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all a user's (non-dismissed) insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsights(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Insight>> {
            const localVarFetchArgs = InsightsApiFetchParamCreator(configuration).getInsights(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InsightsApi - factory interface
 * @export
 */
export const InsightsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Dismiss an insight
         * @param {string} id Numeric ID of the Insight to dismiss
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dismissInsight(id: string, options?: any) {
            return InsightsApiFp(configuration).dismissInsight(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all a user's (non-dismissed) insights
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInsights(options?: any) {
            return InsightsApiFp(configuration).getInsights(options)(fetch, basePath);
        },
    };
};

/**
 * InsightsApi - object-oriented interface
 * @export
 * @class InsightsApi
 * @extends {BaseAPI}
 */
export class InsightsApi extends BaseAPI {
    /**
     *
     * @summary Dismiss an insight
     * @param {string} id Numeric ID of the Insight to dismiss
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public dismissInsight(id: string, options?: any) {
        return InsightsApiFp(this.configuration).dismissInsight(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all a user's (non-dismissed) insights
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightsApi
     */
    public getInsights(options?: any) {
        return InsightsApiFp(this.configuration).getInsights(options)(this.fetch, this.basePath);
    }

}
/**
 * LeaderboardApi - fetch parameter creator
 * @export
 */
export const LeaderboardApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a leaderboard
         * @param {string} type Which leaderboard to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(type: string, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getLeaderboard.');
            }
            const localVarPath = `/leaderboard/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a leaderboard
         * @param {string} type Which leaderboard to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardResponse> {
            const localVarFetchArgs = LeaderboardApiFetchParamCreator(configuration).getLeaderboard(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Get a leaderboard
         * @param {string} type Which leaderboard to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderboard(type: string, options?: any) {
            return LeaderboardApiFp(configuration).getLeaderboard(type, options)(fetch, basePath);
        },
    };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
    /**
     *
     * @summary Get a leaderboard
     * @param {string} type Which leaderboard to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public getLeaderboard(type: string, options?: any) {
        return LeaderboardApiFp(this.configuration).getLeaderboard(type, options)(this.fetch, this.basePath);
    }

}
/**
 * PlaidApi - fetch parameter creator
 * @export
 */
export const PlaidApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary to request link token for PlaidLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidLink(options: any = {}): FetchArgs {
            const localVarPath = `/plaid/link_token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary For after a user does PlaidLink thru client
         * @param {PublicTokenExchangeRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidLinkAccess(body: PublicTokenExchangeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling plaidLinkAccess.');
            }
            const localVarPath = `/plaid/public_token_exchange`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublicTokenExchangeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Where Plaid sends updates about items, transactions, etc https://plaid.com/docs/api/webhooks/
         * @param {PlaidJWT} [plaidVerification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidWebhook(plaidVerification?: PlaidJWT, options: any = {}): FetchArgs {
            const localVarPath = `/plaid/webhook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (plaidVerification !== undefined && plaidVerification !== null) {
                localVarHeaderParameter['Plaid-Verification'] = String(plaidVerification);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaidApi - functional programming interface
 * @export
 */
export const PlaidApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary to request link token for PlaidLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidLink(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LinkTokenCreateResponse> {
            const localVarFetchArgs = PlaidApiFetchParamCreator(configuration).plaidLink(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary For after a user does PlaidLink thru client
         * @param {PublicTokenExchangeRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidLinkAccess(body: PublicTokenExchangeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemIdResponse> {
            const localVarFetchArgs = PlaidApiFetchParamCreator(configuration).plaidLinkAccess(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Where Plaid sends updates about items, transactions, etc https://plaid.com/docs/api/webhooks/
         * @param {PlaidJWT} [plaidVerification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidWebhook(plaidVerification?: PlaidJWT, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PlaidApiFetchParamCreator(configuration).plaidWebhook(plaidVerification, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlaidApi - factory interface
 * @export
 */
export const PlaidApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary to request link token for PlaidLink
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidLink(options?: any) {
            return PlaidApiFp(configuration).plaidLink(options)(fetch, basePath);
        },
        /**
         *
         * @summary For after a user does PlaidLink thru client
         * @param {PublicTokenExchangeRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidLinkAccess(body: PublicTokenExchangeRequest, options?: any) {
            return PlaidApiFp(configuration).plaidLinkAccess(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Where Plaid sends updates about items, transactions, etc https://plaid.com/docs/api/webhooks/
         * @param {PlaidJWT} [plaidVerification]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plaidWebhook(plaidVerification?: PlaidJWT, options?: any) {
            return PlaidApiFp(configuration).plaidWebhook(plaidVerification, options)(fetch, basePath);
        },
    };
};

/**
 * PlaidApi - object-oriented interface
 * @export
 * @class PlaidApi
 * @extends {BaseAPI}
 */
export class PlaidApi extends BaseAPI {
    /**
     *
     * @summary to request link token for PlaidLink
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaidApi
     */
    public plaidLink(options?: any) {
        return PlaidApiFp(this.configuration).plaidLink(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary For after a user does PlaidLink thru client
     * @param {PublicTokenExchangeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaidApi
     */
    public plaidLinkAccess(body: PublicTokenExchangeRequest, options?: any) {
        return PlaidApiFp(this.configuration).plaidLinkAccess(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Where Plaid sends updates about items, transactions, etc https://plaid.com/docs/api/webhooks/
     * @param {PlaidJWT} [plaidVerification]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaidApi
     */
    public plaidWebhook(plaidVerification?: PlaidJWT, options?: any) {
        return PlaidApiFp(this.configuration).plaidWebhook(plaidVerification, options)(this.fetch, this.basePath);
    }

}
/**
 * PlanApi - fetch parameter creator
 * @export
 */
export const PlanApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete one specific plan by id
         * @param {string} id Numeric ID of the Plan to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePlan.');
            }
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get one specific plan by id
         * @param {string} id Numeric ID of the Plan to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlan(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPlan.');
            }
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all of a user's plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlans(options: any = {}): FetchArgs {
            const localVarPath = `/plans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new plan for the user
         * @param {PlanNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newPlan(body: PlanNewPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling newPlan.');
            }
            const localVarPath = `/plan/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PlanNewPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update one specific plan by id
         * @param {string} id Numeric ID of the Plan to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePlan.');
            }
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanApi - functional programming interface
 * @export
 */
export const PlanApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete one specific plan by id
         * @param {string} id Numeric ID of the Plan to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Plan> {
            const localVarFetchArgs = PlanApiFetchParamCreator(configuration).deletePlan(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get one specific plan by id
         * @param {string} id Numeric ID of the Plan to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlan(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Plan> {
            const localVarFetchArgs = PlanApiFetchParamCreator(configuration).getPlan(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all of a user's plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlans(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Plan>> {
            const localVarFetchArgs = PlanApiFetchParamCreator(configuration).getPlans(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a new plan for the user
         * @param {PlanNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newPlan(body: PlanNewPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Plan> {
            const localVarFetchArgs = PlanApiFetchParamCreator(configuration).newPlan(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update one specific plan by id
         * @param {string} id Numeric ID of the Plan to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Plan> {
            const localVarFetchArgs = PlanApiFetchParamCreator(configuration).updatePlan(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlanApi - factory interface
 * @export
 */
export const PlanApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Delete one specific plan by id
         * @param {string} id Numeric ID of the Plan to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan(id: string, options?: any) {
            return PlanApiFp(configuration).deletePlan(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get one specific plan by id
         * @param {string} id Numeric ID of the Plan to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlan(id: string, options?: any) {
            return PlanApiFp(configuration).getPlan(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all of a user's plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlans(options?: any) {
            return PlanApiFp(configuration).getPlans(options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new plan for the user
         * @param {PlanNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newPlan(body: PlanNewPayload, options?: any) {
            return PlanApiFp(configuration).newPlan(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update one specific plan by id
         * @param {string} id Numeric ID of the Plan to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan(id: string, options?: any) {
            return PlanApiFp(configuration).updatePlan(id, options)(fetch, basePath);
        },
    };
};

/**
 * PlanApi - object-oriented interface
 * @export
 * @class PlanApi
 * @extends {BaseAPI}
 */
export class PlanApi extends BaseAPI {
    /**
     *
     * @summary Delete one specific plan by id
     * @param {string} id Numeric ID of the Plan to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public deletePlan(id: string, options?: any) {
        return PlanApiFp(this.configuration).deletePlan(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get one specific plan by id
     * @param {string} id Numeric ID of the Plan to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public getPlan(id: string, options?: any) {
        return PlanApiFp(this.configuration).getPlan(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all of a user's plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public getPlans(options?: any) {
        return PlanApiFp(this.configuration).getPlans(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Creates a new plan for the user
     * @param {PlanNewPayload} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public newPlan(body: PlanNewPayload, options?: any) {
        return PlanApiFp(this.configuration).newPlan(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update one specific plan by id
     * @param {string} id Numeric ID of the Plan to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public updatePlan(id: string, options?: any) {
        return PlanApiFp(this.configuration).updatePlan(id, options)(this.fetch, this.basePath);
    }

}
/**
 * RecurringApi - fetch parameter creator
 * @export
 */
export const RecurringApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete one specific recurring by id
         * @param {string} id Numeric ID of the Recurring to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurring(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRecurring.');
            }
            const localVarPath = `/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get one specific recurring by id
         * @param {string} id Numeric ID of the Recurring to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurring(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRecurring.');
            }
            const localVarPath = `/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get example Recurrings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringExamples(options: any = {}): FetchArgs {
            const localVarPath = `/recurring/examples`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all of a user's recurrings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrings(options: any = {}): FetchArgs {
            const localVarPath = `/recurrings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new recurring for the user
         * @param {RecurringNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newRecurring(body: RecurringNewPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling newRecurring.');
            }
            const localVarPath = `/recurring/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RecurringNewPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update one specific recurring by id
         * @param {RecurringNewPayload} body
         * @param {string} id Numeric ID of the Recurring to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurring(body: RecurringNewPayload, id: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRecurring.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateRecurring.');
            }
            const localVarPath = `/recurring/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RecurringNewPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecurringApi - functional programming interface
 * @export
 */
export const RecurringApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete one specific recurring by id
         * @param {string} id Numeric ID of the Recurring to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurring(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recurring> {
            const localVarFetchArgs = RecurringApiFetchParamCreator(configuration).deleteRecurring(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get one specific recurring by id
         * @param {string} id Numeric ID of the Recurring to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurring(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recurring> {
            const localVarFetchArgs = RecurringApiFetchParamCreator(configuration).getRecurring(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get example Recurrings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringExamples(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RecurringNewPayload>> {
            const localVarFetchArgs = RecurringApiFetchParamCreator(configuration).getRecurringExamples(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all of a user's recurrings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrings(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Recurring>> {
            const localVarFetchArgs = RecurringApiFetchParamCreator(configuration).getRecurrings(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creates a new recurring for the user
         * @param {RecurringNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newRecurring(body: RecurringNewPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recurring> {
            const localVarFetchArgs = RecurringApiFetchParamCreator(configuration).newRecurring(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update one specific recurring by id
         * @param {RecurringNewPayload} body
         * @param {string} id Numeric ID of the Recurring to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurring(body: RecurringNewPayload, id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Recurring> {
            const localVarFetchArgs = RecurringApiFetchParamCreator(configuration).updateRecurring(body, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RecurringApi - factory interface
 * @export
 */
export const RecurringApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Delete one specific recurring by id
         * @param {string} id Numeric ID of the Recurring to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecurring(id: string, options?: any) {
            return RecurringApiFp(configuration).deleteRecurring(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get one specific recurring by id
         * @param {string} id Numeric ID of the Recurring to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurring(id: string, options?: any) {
            return RecurringApiFp(configuration).getRecurring(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get example Recurrings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurringExamples(options?: any) {
            return RecurringApiFp(configuration).getRecurringExamples(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all of a user's recurrings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecurrings(options?: any) {
            return RecurringApiFp(configuration).getRecurrings(options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new recurring for the user
         * @param {RecurringNewPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newRecurring(body: RecurringNewPayload, options?: any) {
            return RecurringApiFp(configuration).newRecurring(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update one specific recurring by id
         * @param {RecurringNewPayload} body
         * @param {string} id Numeric ID of the Recurring to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecurring(body: RecurringNewPayload, id: string, options?: any) {
            return RecurringApiFp(configuration).updateRecurring(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * RecurringApi - object-oriented interface
 * @export
 * @class RecurringApi
 * @extends {BaseAPI}
 */
export class RecurringApi extends BaseAPI {
    /**
     *
     * @summary Delete one specific recurring by id
     * @param {string} id Numeric ID of the Recurring to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurringApi
     */
    public deleteRecurring(id: string, options?: any) {
        return RecurringApiFp(this.configuration).deleteRecurring(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get one specific recurring by id
     * @param {string} id Numeric ID of the Recurring to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurringApi
     */
    public getRecurring(id: string, options?: any) {
        return RecurringApiFp(this.configuration).getRecurring(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get example Recurrings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurringApi
     */
    public getRecurringExamples(options?: any) {
        return RecurringApiFp(this.configuration).getRecurringExamples(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all of a user's recurrings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurringApi
     */
    public getRecurrings(options?: any) {
        return RecurringApiFp(this.configuration).getRecurrings(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Creates a new recurring for the user
     * @param {RecurringNewPayload} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurringApi
     */
    public newRecurring(body: RecurringNewPayload, options?: any) {
        return RecurringApiFp(this.configuration).newRecurring(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update one specific recurring by id
     * @param {RecurringNewPayload} body
     * @param {string} id Numeric ID of the Recurring to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecurringApi
     */
    public updateRecurring(body: RecurringNewPayload, id: string, options?: any) {
        return RecurringApiFp(this.configuration).updateRecurring(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * SnapshotsApi - fetch parameter creator
 * @export
 */
export const SnapshotsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get all a user's snapshots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(options: any = {}): FetchArgs {
            const localVarPath = `/snapshots`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotsApi - functional programming interface
 * @export
 */
export const SnapshotsApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get all a user's snapshots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = SnapshotsApiFetchParamCreator(configuration).getSnapshots(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SnapshotsApi - factory interface
 * @export
 */
export const SnapshotsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Get all a user's snapshots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshots(options?: any) {
            return SnapshotsApiFp(configuration).getSnapshots(options)(fetch, basePath);
        },
    };
};

/**
 * SnapshotsApi - object-oriented interface
 * @export
 * @class SnapshotsApi
 * @extends {BaseAPI}
 */
export class SnapshotsApi extends BaseAPI {
    /**
     *
     * @summary Get all a user's snapshots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public getSnapshots(options?: any) {
        return SnapshotsApiFp(this.configuration).getSnapshots(options)(this.fetch, this.basePath);
    }

}
/**
 * TimeseriesApi - fetch parameter creator
 * @export
 */
export const TimeseriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a user's projection timeseries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseries(options: any = {}): FetchArgs {
            const localVarPath = `/timeseries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeseriesApi - functional programming interface
 * @export
 */
export const TimeseriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get a user's projection timeseries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TimeSeries> {
            const localVarFetchArgs = TimeseriesApiFetchParamCreator(configuration).getTimeseries(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TimeseriesApi - factory interface
 * @export
 */
export const TimeseriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Get a user's projection timeseries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeseries(options?: any) {
            return TimeseriesApiFp(configuration).getTimeseries(options)(fetch, basePath);
        },
    };
};

/**
 * TimeseriesApi - object-oriented interface
 * @export
 * @class TimeseriesApi
 * @extends {BaseAPI}
 */
export class TimeseriesApi extends BaseAPI {
    /**
     *
     * @summary Get a user's projection timeseries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeseriesApi
     */
    public getTimeseries(options?: any) {
        return TimeseriesApiFp(this.configuration).getTimeseries(options)(this.fetch, this.basePath);
    }

}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Log in a user
         * @param {LoginPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: LoginPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginUser.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Sign up a user
         * @param {SignupPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser(body: SignupPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling signupUser.');
            }
            const localVarPath = `/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignupPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Log in a user
         * @param {LoginPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: LoginPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).loginUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Sign up a user
         * @param {SignupPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser(body: SignupPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).signupUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Log in a user
         * @param {LoginPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: LoginPayload, options?: any) {
            return UserApiFp(configuration).loginUser(body, options)(fetch, basePath);
        },
        /**
         *
         * @summary Sign up a user
         * @param {SignupPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser(body: SignupPayload, options?: any) {
            return UserApiFp(configuration).signupUser(body, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @summary Log in a user
     * @param {LoginPayload} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginUser(body: LoginPayload, options?: any) {
        return UserApiFp(this.configuration).loginUser(body, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Sign up a user
     * @param {SignupPayload} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public signupUser(body: SignupPayload, options?: any) {
        return UserApiFp(this.configuration).signupUser(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary This route will be called once a user logs in on an iOS device and route body will contain the URL of the iOS device, this will be stored in the User model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerIOSDevice(options: any = {}): FetchArgs {
            const localVarPath = `/registerIOSDevice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary This route receives a payload with requests to change data of a user
         * @param {UpdateUserRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            const localVarPath = `/update/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sidCookie required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("finch-sid")
					: configuration.apiKey;
                localVarQueryParameter["finch-sid"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary This route will be called once a user logs in on an iOS device and route body will contain the URL of the iOS device, this will be stored in the User model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerIOSDevice(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiError> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).registerIOSDevice(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary This route receives a payload with requests to change data of a user
         * @param {UpdateUserRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary This route will be called once a user logs in on an iOS device and route body will contain the URL of the iOS device, this will be stored in the User model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerIOSDevice(options?: any) {
            return UsersApiFp(configuration).registerIOSDevice(options)(fetch, basePath);
        },
        /**
         *
         * @summary This route receives a payload with requests to change data of a user
         * @param {UpdateUserRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, options?: any) {
            return UsersApiFp(configuration).updateUser(body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     *
     * @summary This route will be called once a user logs in on an iOS device and route body will contain the URL of the iOS device, this will be stored in the User model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public registerIOSDevice(options?: any) {
        return UsersApiFp(this.configuration).registerIOSDevice(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary This route receives a payload with requests to change data of a user
     * @param {UpdateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(body: UpdateUserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ValidationApi - fetch parameter creator
 * @export
 */
export const ValidationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary This route lets our clients perform step-by-step signups.
         * @param {ValidateUserPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUser(body: ValidateUserPayload, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling validateUser.');
            }
            const localVarPath = `/validate/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ValidateUserPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidationApi - functional programming interface
 * @export
 */
export const ValidationApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary This route lets our clients perform step-by-step signups.
         * @param {ValidateUserPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUser(body: ValidateUserPayload, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ValidationApiFetchParamCreator(configuration).validateUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ValidationApi - factory interface
 * @export
 */
export const ValidationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary This route lets our clients perform step-by-step signups.
         * @param {ValidateUserPayload} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUser(body: ValidateUserPayload, options?: any) {
            return ValidationApiFp(configuration).validateUser(body, options)(fetch, basePath);
        },
    };
};

/**
 * ValidationApi - object-oriented interface
 * @export
 * @class ValidationApi
 * @extends {BaseAPI}
 */
export class ValidationApi extends BaseAPI {
    /**
     *
     * @summary This route lets our clients perform step-by-step signups.
     * @param {ValidateUserPayload} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationApi
     */
    public validateUser(body: ValidateUserPayload, options?: any) {
        return ValidationApiFp(this.configuration).validateUser(body, options)(this.fetch, this.basePath);
    }

}
